{"ast":null,"code":"/**\n * Generic method to test regex\n *\n * @private\n * @param {string} regex - regex to test\n *                           with password\n */\nvar regex = require('./constants').regex;\n\nfunction _process(regexp, repeat) {\n  if (repeat && repeat > 1) {\n    const parsedRepeat = parseInt(repeat, 10);\n    return new RegExp(regexp + '{' + parsedRepeat + ',}').test(this.password) === this.positive;\n  }\n\n  return new RegExp(regexp).test(this.password) === this.positive;\n}\n\nmodule.exports = {\n  /**\n   * Method to invert the next validations\n   *\n   * @param {RegExp} [symbol] - custom Regex which should not be present\n   */\n  not: function not(symbol) {\n    this.positive = false;\n\n    if (symbol) {\n      return _process.call(this, symbol);\n    }\n\n    return true;\n  },\n\n  /**\n   * Method to invert the effects of not()\n   *\n   * @param {RegExp} [symbol] - custom Regex which should be present\n   */\n  has: function has(symbol) {\n    this.positive = true;\n\n    if (symbol) {\n      return _process.call(this, symbol);\n    }\n\n    return true;\n  },\n\n  /**\n   * Method to invert the effects of not() and\n   * to make the api readable and chainable\n   *\n   */\n  is: function is() {\n    this.positive = true;\n    return true;\n  },\n\n  /**\n   * Method to specify a minimum length\n   *\n   * @param {number} num - minimum length\n   */\n  min: function min(num) {\n    return this.password.length >= num;\n  },\n\n  /**\n   * Method to specify a maximum length\n   *\n   * @param {number} num - maximum length\n   */\n  max: function max(num) {\n    return this.password.length <= num;\n  },\n\n  /**\n   * Method to validate the presence of digits\n   *\n   * @param {number} repeat - count of required digits\n   */\n  digits: function digits(repeat) {\n    return _process.call(this, regex.digits, repeat);\n  },\n\n  /**\n   * Method to validate the presence of letters\n   *\n   * @param {number} repeat - count of required letters\n   */\n  letters: function letters(repeat) {\n    return _process.call(this, regex.letters, repeat);\n  },\n\n  /**\n   * Method to validate the presence of uppercase letters\n   *\n   * @param {number} repeat - count of required uppercase letters\n   */\n  uppercase: function uppercase(repeat) {\n    if (repeat && repeat > 1) {\n      let characterIndex = 0;\n      let upperCaseLetters = 0;\n\n      while (upperCaseLetters < repeat && characterIndex < this.password.length) {\n        const currentLetter = this.password.charAt(characterIndex);\n\n        if (currentLetter !== currentLetter.toLowerCase()) {\n          upperCaseLetters++;\n        }\n\n        characterIndex++;\n      }\n\n      return upperCaseLetters === repeat === this.positive;\n    }\n\n    return this.password !== this.password.toLowerCase() === this.positive;\n  },\n\n  /**\n   * Method to validate the presence of lowercase letters\n   *\n   * @param {number} repeat - count of required lowercase letters\n   */\n  lowercase: function lowercase(repeat) {\n    if (repeat && repeat > 1) {\n      let characterIndex = 0;\n      let lowerCaseLetters = 0;\n\n      while (lowerCaseLetters < repeat && characterIndex < this.password.length) {\n        const currentLetter = this.password.charAt(characterIndex);\n\n        if (currentLetter !== currentLetter.toUpperCase()) {\n          lowerCaseLetters++;\n        }\n\n        characterIndex++;\n      }\n\n      return lowerCaseLetters === repeat === this.positive;\n    }\n\n    return this.password !== this.password.toUpperCase() === this.positive;\n  },\n\n  /**\n   * Method to validate the presence of symbols\n   *\n   * @param {number} repeat - count of required symbols\n   */\n  symbols: function symbols(repeat) {\n    return _process.call(this, regex.symbols, repeat);\n  },\n\n  /**\n   * Method to validate the presence of space\n   *\n   * @param {number} repeat - count of required spaces\n   */\n  spaces: function spaces(repeat) {\n    return _process.call(this, regex.spaces, repeat);\n  },\n\n  /**\n   * Method to provide pre-defined values for password\n   *\n   * @param {array} list - list of values allowed\n   */\n  oneOf: function oneOf(list) {\n    return list.indexOf(this.password) >= 0 === this.positive;\n  }\n};","map":{"version":3,"sources":["D:/gitHub_projects/Stock/src/main/ui/node_modules/password-validator/src/lib.js"],"names":["regex","require","_process","regexp","repeat","parsedRepeat","parseInt","RegExp","test","password","positive","module","exports","not","symbol","call","has","is","min","num","length","max","digits","letters","uppercase","characterIndex","upperCaseLetters","currentLetter","charAt","toLowerCase","lowercase","lowerCaseLetters","toUpperCase","symbols","spaces","oneOf","list","indexOf"],"mappings":"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","sourcesContent":["/**\n * Generic method to test regex\n *\n * @private\n * @param {string} regex - regex to test\n *                           with password\n */\nvar regex = require('./constants').regex;\n\nfunction _process(regexp, repeat) {\n  if (repeat && repeat > 1) {\n    const parsedRepeat = parseInt(repeat, 10);\n    return new RegExp(regexp + '{' + parsedRepeat + ',}').test(this.password) === this.positive;\n  }\n  return new RegExp(regexp).test(this.password) === this.positive;\n}\n\nmodule.exports = {\n\n  /**\n   * Method to invert the next validations\n   *\n   * @param {RegExp} [symbol] - custom Regex which should not be present\n   */\n  not: function not(symbol) {\n    this.positive = false;\n    if (symbol) {\n      return _process.call(this, symbol);\n    }\n    return true;\n  },\n\n  /**\n   * Method to invert the effects of not()\n   *\n   * @param {RegExp} [symbol] - custom Regex which should be present\n   */\n  has: function has(symbol) {\n    this.positive = true;\n    if (symbol) {\n      return _process.call(this, symbol);\n    }\n    return true;\n  },\n\n  /**\n   * Method to invert the effects of not() and\n   * to make the api readable and chainable\n   *\n   */\n  is: function is() {\n    this.positive = true;\n    return true;\n  },\n\n  /**\n   * Method to specify a minimum length\n   *\n   * @param {number} num - minimum length\n   */\n  min: function min(num) {\n    return this.password.length >= num;\n  },\n\n  /**\n   * Method to specify a maximum length\n   *\n   * @param {number} num - maximum length\n   */\n  max: function max(num) {\n    return this.password.length <= num;\n  },\n\n  /**\n   * Method to validate the presence of digits\n   *\n   * @param {number} repeat - count of required digits\n   */\n  digits: function digits(repeat) {\n    return _process.call(this, regex.digits, repeat);\n  },\n\n  /**\n   * Method to validate the presence of letters\n   *\n   * @param {number} repeat - count of required letters\n   */\n  letters: function letters(repeat) {\n    return _process.call(this, regex.letters, repeat);\n  },\n\n  /**\n   * Method to validate the presence of uppercase letters\n   *\n   * @param {number} repeat - count of required uppercase letters\n   */\n  uppercase: function uppercase(repeat) {\n    if (repeat && repeat > 1) {\n      let characterIndex = 0;\n      let upperCaseLetters = 0;\n\n      while ((upperCaseLetters < repeat) && (characterIndex < this.password.length)) {\n        const currentLetter = this.password.charAt(characterIndex);\n        if (currentLetter !== currentLetter.toLowerCase()) {\n          upperCaseLetters++;\n        }\n        characterIndex++;\n      }\n\n      return (upperCaseLetters === repeat) === this.positive;\n    }\n    return (this.password !== this.password.toLowerCase()) === this.positive;\n  },\n\n  /**\n   * Method to validate the presence of lowercase letters\n   *\n   * @param {number} repeat - count of required lowercase letters\n   */\n  lowercase: function lowercase(repeat) {\n    if (repeat && repeat > 1) {\n      let characterIndex = 0;\n      let lowerCaseLetters = 0;\n\n      while ((lowerCaseLetters < repeat) && (characterIndex < this.password.length)) {\n        const currentLetter = this.password.charAt(characterIndex);\n        if (currentLetter !== currentLetter.toUpperCase()) {\n          lowerCaseLetters++;\n        }\n        characterIndex++;\n      }\n\n      return (lowerCaseLetters === repeat) === this.positive;\n    }\n    return (this.password !== this.password.toUpperCase()) === this.positive;\n  },\n\n  /**\n   * Method to validate the presence of symbols\n   *\n   * @param {number} repeat - count of required symbols\n   */\n  symbols: function symbols(repeat) {\n    return _process.call(this, regex.symbols, repeat);\n  },\n\n  /**\n   * Method to validate the presence of space\n   *\n   * @param {number} repeat - count of required spaces\n   */\n  spaces: function spaces(repeat) {\n    return _process.call(this, regex.spaces, repeat);\n  },\n\n  /**\n   * Method to provide pre-defined values for password\n   *\n   * @param {array} list - list of values allowed\n   */\n  oneOf: function oneOf(list) {\n    return list.indexOf(this.password) >= 0 === this.positive;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}